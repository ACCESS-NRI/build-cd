name: CI
run-name: ${{ inputs.model }} CI
# NOTE: This workflow requires:
# For the pull_request version of the workflow:
#   permissions.pull-requests:write
#   secrets:inherit with an appropriate GitHub Environment for deployment in the caller
# For the !redeploy issue_comment version of the workflow:
#   permissions.pull-requests:write
#   permissions.statuses:write
#   secrets:inherit with an appropriate GitHub Environment for deployment in the caller
on:
  workflow_call:
    inputs:
      model:
        type: string
        required: true
        description: The model that is being tested and deployed
      root-sbd:
        type: string
        required: false
        # default: The ${{ inputs.model }} above
        description: |
          The name of the root Spack Bundle Definition, if it is different from the model name.
          This is often a package named similarly in ACCESS-NRI/spack-packages.
      pr:
        type: string
        required: true
        description: The pull request number that will be deployed as a prerelease
  # Callers usually have the trigger:
  # pull_request:
  #   branches:
  #     - main
  #     - backport/*.*
  #   paths:
  #     - config/**
  #     - spack.yaml
  # issue_comment:
  #   types:
  #     - created
  #     - edited
env:
  RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
jobs:
  defaults:
    name: Set Defaults
    # Unfortunately, you can't set a dynamic default value based on `inputs` yet.
    # We also set the PR and branch metadata here because it's used in multiple places,
    # including the deploy reusable workflow, which can't access the `env` context.
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}
    outputs:
      root-sbd: ${{ steps.root-sbd.outputs.default }}
      head-ref: ${{ steps.pr.outputs.head }}
      head-sha: ${{ steps.pr.outputs.sha }}
      base-ref: ${{ steps.pr.outputs.base }}
      next-deployment-number: ${{ steps.prerelease.outputs.next-deployment-number }}
      prerelease-version: ${{ steps.prerelease.outputs.version }}
      targets: ${{ steps.target.outputs.valid-targets }}
    steps:
      - name: root-sbd default
        id: root-sbd
        run: |
          if [[ "${{ inputs.root-sbd }}" == "" ]]; then
            echo "default=${{ inputs.model }}" >> $GITHUB_OUTPUT
          else
            echo "default=${{ inputs.root-sbd }}" >> $GITHUB_OUTPUT
          fi

      - name: PR metadata
        id: pr
        run: |
          pr_metadata=$(gh pr view ${{ inputs.pr }} --repo ${{ github.repository }} --json headRefName,headRefOid,baseRefName)
          if [ -z "$pr_metadata" ]; then
            echo "::error::Failed to get PR ${{ inputs.pr }} metadata."
            exit 1
          fi

          head=$(jq --null-input --raw-output --compact-output \
            --argjson pr "$pr_metadata" \
            '$pr.headRefName'
          )
          sha=$(jq --null-input --raw-output --compact-output \
            --argjson pr "$pr_metadata" \
            '$pr.headRefOid'
          )
          base=$(jq --null-input --raw-output --compact-output \
            --argjson pr "$pr_metadata" \
            '$pr.baseRefName'
          )

          echo "PR ${{ inputs.pr }} with '$head' ('$sha') -> '$base'"
          echo "head=$head" >> $GITHUB_OUTPUT
          echo "sha=$sha" >> $GITHUB_OUTPUT
          echo "base=$base" >> $GITHUB_OUTPUT

      - name: Branch metadata
        id: prerelease
        # Essentially, count all the deployment entries that match the given branch, as well as
        # all the `!redeploy` comments, to get the next deployment number.
        # See https://docs.github.com/en/rest/deployments/deployments?apiVersion=2022-11-28#list-deployments
        run: |
          # We --slurp the results because --paginate introduces potentially multiple array results
          pr_deployments=$(gh api \
              -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" \
              --paginate --slurp \
              /repos/${{ github.repository }}/deployments \
            | jq '[select(.[][].ref == "${{ steps.pr.outputs.head }}")] | length'
          )
          comment_deployments=$(gh pr view ${{ inputs.pr }} --repo ${{ github.repository }} \
            --json comments \
            --jq '[.comments[] | select(.body | startswith("!redeploy"))] | length'
          )

          # Since the number of $pr_deployments do not include the current deployment (yet),
          # but $comment_deployments do, we need to increment the next deployment number by one if it is a pr deployment.
          next_deployment_is_pr_deployment=${{ github.event_name == 'pull_request' && '1' || '0' }}
          next_deployment_number=$((pr_deployments + comment_deployments + next_deployment_is_pr_deployment))
          echo "Next Deployment Number is $pr_deployments + $comment_deployments + $next_deployment_is_pr_deployment = $next_deployment_number"
          echo "next-deployment-number=$next_deployment_number" >> $GITHUB_OUTPUT

          version="pr${{ inputs.pr }}-$next_deployment_number"
          echo "Prerelease version will be $version"
          echo "version=$version" >> $GITHUB_OUTPUT

      - name: Generate Deployment Target Matrix
        id: target
        uses: access-nri/build-cd/.github/actions/get-target-matrix@dev-121-multi-target-workflows_TEST
        with:
          targets: ${{ vars.PRERELEASE_DEPLOYMENT_TARGETS }}

  redeploy-pre:
    name: '!redeploy Pending'
    if: github.event_name == 'issue_comment' && startsWith(github.event.comment.body, '!redeploy')
    needs:
      - defaults
    runs-on: ubuntu-latest
    permissions:
      statuses: write
      pull-requests: write
    outputs:
      # String to differentiate the status of redeploys vs other checks
      commit-status-context: ${{ steps.commit-status-args.outputs.context }}
      # String to describe the overall check
      commit-status-description: ${{ steps.commit-status-args.outputs.description }}
    steps:
      - name: Check commenter permissions
        id: commenter
        uses: access-nri/actions/.github/actions/commenter-permission-check@main
        with:
          # This means that commenters who use `!redeploy` must have at least `write` perms
          # in the repository. `write` is probably the best fit.
          minimum-permission: write

      - name: React to Comment
        uses: access-nri/actions/.github/actions/react-to-comment@main
        with:
          token: ${{ github.token }}
          reaction: ${{ steps.commenter.outputs.has-permission == 'true' && 'rocket' || '-1' }}

      - name: Exit if no write permissions
        if: steps.commenter.outputs.has-permission == 'false'
        run: |
          echo "::error::User ${{ github.event.comment.user.login }} doesn't have 'write' permission on ${{ github.repository }}, not allowing deployment"
          exit 1

      - name: Set Commit Status Args
        id: commit-status-args
        # We don't want to use history expansion (the '!')
        shell: bash +H {0}
        run: |
          echo 'context=!redeploy Number ${{ needs.defaults.outputs.next-deployment-number }}' >> $GITHUB_OUTPUT
          echo 'description=Redeploy Prerelease' >> $GITHUB_OUTPUT

      - name: Set Commit Status Pending
        uses: myrotvorets/set-commit-status-action@3730c0a348a2ace3c110851bed53331bc6406e9f  # v2.0.1
        with:
          status: pending
          sha: ${{ needs.defaults.outputs.head-sha }}
          context: ${{ steps.commit-status-args.outputs.context }}
          description: ${{ steps.commit-status-args.outputs.description }}

  deploy:
    name: Deploy
    needs:
      - defaults
    strategy:
      fail-fast: false
      matrix:
        # Example: ['Gadi', 'Setonix', ...]
        target: ${{ fromJson(needs.defaults.outputs.targets) }}
    uses: access-nri/build-cd/.github/workflows/deploy-1-setup.yml@dev-121-multi-target-workflows_TEST
    with:
      deployment-target: ${{ matrix.target }}
      deployment-ref: ${{ needs.defaults.outputs.head-ref }}
      deployment-type: Prerelease
      # The prerelease looks like: `pr<pull request number>-<number of deployments of pull request>`.
      # Ex. Pull Request #12 with 2 deployments on branch -> `pr12-2`.
      # Note that for multi-target prereleases, they share the same deployment number.
      deployment-version: ${{ needs.defaults.outputs.prerelease-version }}
      prerelease-compare-ref: ${{ needs.defaults.outputs.base-ref }}
      spack-manifest-path: ./spack.yaml
      spack-manifest-root-sbd: ${{ needs.defaults.outputs.root-sbd }}
    secrets: inherit

  redeploy-post:
    name: '!redeploy Status ${{ needs.deploy.result }}'
    # Always set the commit status after the redeploy job - don't want an always pending status!
    # successful redeploy = successful commit status
    # failed, skipped, cancelled redeploy = failure commit status
    if: always() && needs.redeploy-pre.result == 'success'
    needs:
      - defaults  # to get access to the head-sha
      - redeploy-pre  # to get the initial commit status context and description
      - deploy  # to get the overall status of this workflow
    runs-on: ubuntu-latest
    permissions:
      statuses: write  # so we can set the commit status!
      pull-requests: write  # so we can react to the comment
    steps:
      - name: React to Comment
        uses: access-nri/actions/.github/actions/react-to-comment@main
        with:
          token: ${{ github.token }}
          reaction: ${{ needs.deploy.result == 'success' && '+1' || '-1' }}

      - name: Set commit status from workflow ${{ needs.deploy.result }}
        uses: myrotvorets/set-commit-status-action@3730c0a348a2ace3c110851bed53331bc6406e9f  # v2.0.1
        with:
          status: ${{ needs.deploy.result == 'success' && 'success' || 'failure' }}
          sha: ${{ needs.defaults.outputs.head-sha }}
          context: ${{ needs.redeploy-pre.outputs.commit-status-context }}
          description: ${{ needs.redeploy-pre.outputs.commit-status-description }}

  post-deploy-notifier:
    name: Post-Deploy Notifier
    if: always()
    needs:
      - defaults  # so we can access `inputs.root-sbd` that could have defaulted to `inputs.model`
      - deploy  # so we can access deployment information such as versions used, status of deployments, etc.
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    env:
      OUTPUT_ARTIFACT_PATH: ./merged_outputs
      TEMPLATED_COMMENT_BODY_PATH: /opt/comment-body.md
    steps:
      - name: Checkout build-cd for scripts
        uses: actions/checkout@v4
        with:
          repository: access-nri/build-cd
          ref: dev-121-multi-target-workflows_TEST

      - name: Download matrix deployment outputs
        uses: actions/download-artifact@v4
        with:
          pattern: ${{ needs.deploy.outputs.general-outputs-artifact-glob }}
          path: ${{ env.OUTPUT_ARTIFACT_PATH }}
          merge-multiple: true

      - name: Config status roll up
        id: config-rollup
        # Roll up the config status booleans from each of the files, and return the overall result
        run: |
          echo "errors=$(jq --slurp 'map(.ci_configuration_check_failure | any)' ${{ env.OUTPUT_ARTIFACT_PATH }}/*)" >> $GITHUB_OUTPUT

      - name: Deployment status roll up
        id: deployment-rollup
        # Roll up the deployment status from each of the files, and return the overall result
        # In other words, if any of the deployments are not a success (AKA, failure/skipped/cancelled), then the overall status is failure
        run: |
          echo "errors=$(jq --slurp 'map(.deployment_result == "success") | all | not' ${{ env.OUTPUT_ARTIFACT_PATH }}/*)" >> $GITHUB_OUTPUT

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.12
          cache: pip

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -q -q -r scripts/jinja_template/requirements.txt

      - name: Create deployment message
        id: matrix-output-parser
        # Outputs defined in deploy-1-setup.yml under the outputs-upload job
        # Creates a comment of the form: https://github.com/ACCESS-NRI/ACCESS-TEST/pull/15#issuecomment-2558675980
        env:
          J2_MODEL: ${{ inputs.model }}
          J2_PRERELEASE_VERSION: ${{ needs.defaults.outputs.prerelease-version }}
          J2_ROOT_SBD: ${{ needs.defaults.outputs.root-sbd }}
          J2_DEPLOYMENT_ERRORS: ${{ steps.deployment-rollup.outputs.errors }}
          J2_CONFIG_ERRORS: ${{ steps.config-rollup.outputs.errors }}
          J2_HEAD_SHA: ${{ needs.defaults.outputs.head-sha }}
          J2_RUN_URL: ${{ env.RUN_URL }}
        run: |
          python -m scripts.jinja_template.render_deployment_info \
            --template scripts/jinja_template/templates/deployment-comment-body.md.j2 \
            --deployment-outputs ${{ env.OUTPUT_ARTIFACT_PATH }} \
            --output ${{ env.TEMPLATED_COMMENT_BODY_PATH }}

      - name: PR Comment Notifier
        id: comment
        uses: access-nri/actions/.github/actions/pr-comment@main
        with:
          comment-file: ${{ env.TEMPLATED_COMMENT_BODY_PATH }}

      - name: PR Description Notifier
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY_PATH: ./body.txt
          PR_BODY_PATH_UPDATED: ./updated.body.txt
          PRERELEASE_SECTION_REGEX: "^:rocket: .* :rocket:$"
          PRERELEASE_SECTION: ":rocket: The latest prerelease `${{ needs.defaults.outputs.root-sbd }}/${{ needs.defaults.outputs.prerelease-version }}` at ${{ needs.defaults.outputs.head-sha }} is here: ${{ steps.comment.outputs.comment-link }} :rocket:"
        run: |
          gh pr view ${{ inputs.pr }} --repo ${{ github.repository }} --json body --jq .body > ${{ env.PR_BODY_PATH }}

          # `awk` is a series of `CONDITION { ACTION }` pairs. No 'CONDITION' means 'TRUE', no '{ ACTION }' means 'print'.
          if grep -q '${{ env.PRERELEASE_SECTION_REGEX }}' ${{ env.PR_BODY_PATH }}; then  # there is an existing prerelease section
            # Replace the existing prerelease section
            # `{gsub(...)}`. Always attempt substitution on each line, then:
            # `1`. Always do the default action '{ print }').
            awk '{gsub(/${{ env.PRERELEASE_SECTION_REGEX }}/, "${{ env.PRERELEASE_SECTION }}")}1' ${{ env.PR_BODY_PATH }} > ${{ env.PR_BODY_PATH_UPDATED }}
          else  # a new section is added
            # `1;` -> `TRUE { print }`. Always do the default action (aka 'print') for each line.
            # `END {print(...)}`. If end of file, print the prerelease section.
            awk '1; END {print "\n---\n${{ env.PRERELEASE_SECTION }}"}' ${{ env.PR_BODY_PATH }} > ${{ env.PR_BODY_PATH_UPDATED }}
          fi

          cat ${{ env.PR_BODY_PATH_UPDATED }}

          gh pr edit ${{ inputs.pr }} --repo ${{ github.repository }} --body-file ${{ env.PR_BODY_PATH_UPDATED }}
