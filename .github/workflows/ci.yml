name: CI
run-name: ${{ inputs.model }} CI
# NOTE: This workflow requires:
# For the pull_request version of the workflow:
#   permissions.pull-requests:write
#   secrets:inherit with an appropriate GitHub Environment for deployment in the caller
# For the !redeploy issue_comment version of the workflow:
#   permissions.pull-requests:write
#   permissions.statuses:write
#   secrets:inherit with an appropriate GitHub Environment for deployment in the caller
on:
  workflow_call:
    inputs:
      model:
        type: string
        required: true
        description: The model that is being tested and deployed
      root-sbd:
        type: string
        required: false
        # default: The ${{ inputs.model }} above
        description: |
          The name of the root Spack Bundle Definition, if it is different from the model name.
          This is often a package named similarly in ACCESS-NRI/spack-packages.
      pr:
        type: string
        required: true
        description: The pull request number that will be deployed as a prerelease
  # Callers usually have the trigger:
  # pull_request:
  #   branches:
  #     - main
  #     - backport/*.*
  #   paths:
  #     - config/**
  #     - spack.yaml
  # issue_comment:
  #   types:
  #     - created
  #     - edited
env:
  SPACK_YAML_MODEL_YQ: .spack.specs[0]
jobs:
  defaults:
    name: Set Defaults
    # Unfortunately, you can't set a dynamic default value based on `inputs` yet.
    # We also set the PR and branch metadata here because it's used in multiple places,
    # including the deploy reusable workflow, which can't access the `env` context.
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}
    outputs:
      root-sbd: ${{ steps.root-sbd.outputs.default }}
      head-ref: ${{ steps.pr.outputs.head }}
      head-sha: ${{ steps.pr.outputs.sha }}
      base-ref: ${{ steps.pr.outputs.base }}
      next-deployment-number: ${{ steps.branch.outputs.next-deployment-number }}
    steps:
      - name: root-sbd default
        id: root-sbd
        run: |
          if [[ "${{ inputs.root-sbd }}" == "" ]]; then
            echo "default=${{ inputs.model }}" >> $GITHUB_OUTPUT
          else
            echo "default=${{ inputs.root-sbd }}" >> $GITHUB_OUTPUT
          fi

      - name: PR metadata
        id: pr
        run: |
          pr_metadata=$(gh pr view ${{ inputs.pr }} --repo ${{ github.repository }} --json headRefName,headRefOid,baseRefName)
          if [ -z "$pr_metadata" ]; then
            echo "::error::Failed to get PR ${{ inputs.pr }} metadata."
            exit 1
          fi

          head=$(jq --null-input --raw-output --compact-output \
            --argjson pr "$pr_metadata" \
            '$pr.headRefName'
          )
          sha=$(jq --null-input --raw-output --compact-output \
            --argjson pr "$pr_metadata" \
            '$pr.headRefOid'
          )
          base=$(jq --null-input --raw-output --compact-output \
            --argjson pr "$pr_metadata" \
            '$pr.baseRefName'
          )

          echo "PR ${{ inputs.pr }} with '$head' ('$sha') -> '$base'"
          echo "head=$head" >> $GITHUB_OUTPUT
          echo "sha=$sha" >> $GITHUB_OUTPUT
          echo "base=$base" >> $GITHUB_OUTPUT

      - name: Branch metadata
        id: branch
        # Essentially, count all the deployment entries that match the given branch, as well as
        # all the `!redeploy` comments, to get the next deployment number.
        # See https://docs.github.com/en/rest/deployments/deployments?apiVersion=2022-11-28#list-deployments
        run: |
          # We --slurp the results because --paginate introduces potentially multiple array results
          pr_deployments=$(gh api \
              -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" \
              --paginate --slurp \
              /repos/${{ github.repository }}/deployments \
            | jq '[select(.[][].ref == "${{ steps.pr.outputs.head }}")] | length'
          )
          comment_deployments=$(gh pr view ${{ inputs.pr }} --repo ${{ github.repository }} \
            --json comments \
            --jq '[.comments[] | select(.body | startswith("!redeploy"))] | length'
          )
          # Since the number of $pr_deployments do not include the current deployment (yet),
          # but $comment_deployments do, we need to increment the next deployment number by one if it is a pr deployment.
          next_deployment_is_pr_deployment=${{ github.event_name == 'pull_request' && '1' || '0' }}
          next_deployment_number=$((pr_deployments + comment_deployments + next_deployment_is_pr_deployment))
          echo "Next Deployment Number is $pr_deployments + $comment_deployments + $next_deployment_is_pr_deployment = $next_deployment_number"
          echo "next-deployment-number=$next_deployment_number" >> $GITHUB_OUTPUT

  redeploy-pre:
    name: '!redeploy Pending'
    if: github.event_name == 'issue_comment' && startsWith(github.event.comment.body, '!redeploy')
    needs:
      - defaults
    runs-on: ubuntu-latest
    permissions:
      statuses: write
      pull-requests: write
    outputs:
      # String to differentiate the status of redeploys vs other checks
      commit-status-context: ${{ steps.commit-status-args.outputs.context }}
      # String to describe the overall check
      commit-status-description: ${{ steps.commit-status-args.outputs.description }}
    steps:
      - name: Check commenter permissions
        id: commenter
        uses: access-nri/actions/.github/actions/commenter-permission-check@main
        with:
          # This means that commenters who use `!redeploy` must have at least `write` perms
          # in the repository. `write` is probably the best fit.
          minimum-permission: write

      - name: React to Comment
        uses: access-nri/actions/.github/actions/react-to-comment@main
        with:
          token: ${{ github.token }}
          reaction: ${{ steps.commenter.outputs.has-permission == 'true' && 'rocket' || '-1' }}

      - name: Exit if no write permissions
        if: steps.commenter.outputs.has-permission == 'false'
        run: |
          echo "User ${{ github.event.comment.user.login }} doesn't have 'write' permission on ${{ github.repository }}, not allowing deployment"
          exit 1

      - name: Set Commit Status Args
        id: commit-status-args
        # We don't want to use history expansion (the '!')
        shell: bash +H {0}
        run: |
          echo 'context=!redeploy Number ${{ needs.defaults.outputs.next-deployment-number }}' >> $GITHUB_OUTPUT
          echo 'description=Redeploy Prerelease' >> $GITHUB_OUTPUT

      - name: Set Commit Status Pending
        uses: myrotvorets/set-commit-status-action@3730c0a348a2ace3c110851bed53331bc6406e9f  # v2.0.1
        with:
          status: pending
          sha: ${{ needs.defaults.outputs.head-sha }}
          context: ${{ steps.commit-status-args.outputs.context }}
          description: ${{ steps.commit-status-args.outputs.description }}

  deploy:
    name: Deploy
    needs:
      - defaults
    strategy:
      fail-fast: false
      matrix:
        # Example: ['Gadi', 'Setonix', ...]
        target: ${{ fromJson(needs.defaults.outputs.targets) }}
    uses: access-nri/build-cd/.github/workflows/deploy-1-setup.yml@main
    with:
      deployment-target: ${{ matrix.target }}
      deployment-ref: ${{ needs.defaults.outputs.head-ref }}
      deployment-type: Prerelease
      # The prerelease looks like: `pr<pull request number>-<number of deployments of pull request>`.
      # Ex. Pull Request #12 with 2 deployments on branch -> `pr12-2`.
      # Note that for multi-target prereleases, they share the same deployment number.
      deployment-version: ${{ needs.defaults.outputs.prerelease-version }}
      prerelease-compare-ref: ${{ needs.defaults.outputs.base-ref }}
      spack-manifest-path: ./spack.yaml
      spack-manifest-root-sbd: ${{ needs.defaults.outputs.root-sbd }}
    secrets: inherit

  redeploy-post:
    name: '!redeploy Status ${{ needs.prerelease-deploy.result }}'
    # Always set the commit status after the redeploy job - don't want an always pending status!
    # successful redeploy = successful commit status
    # failed, skipped, cancelled redeploy = failure commit status
    if: always() && needs.redeploy-pre.result == 'success'
    needs:
      - defaults  # to get access to the head-sha
      - redeploy-pre  # to get the initial commit status context and description
      - prerelease-deploy  # to get the overall status of this workflow
    runs-on: ubuntu-latest
    permissions:
      statuses: write  # so we can set the commit status!
      pull-requests: write  # so we can react to the comment
    steps:
      - name: React to Comment
        uses: access-nri/actions/.github/actions/react-to-comment@main
        with:
          token: ${{ github.token }}
          reaction: ${{ needs.prerelease-deploy.result == 'success' && '+1' || '-1' }}

      - name: Set commit status from workflow ${{ needs.prerelease-deploy.result }}
        uses: myrotvorets/set-commit-status-action@3730c0a348a2ace3c110851bed53331bc6406e9f  # v2.0.1
        with:
          status: ${{ needs.prerelease-deploy.result == 'success' && 'success' || 'failure' }}
          sha: ${{ needs.defaults.outputs.head-sha }}
          context: ${{ needs.redeploy-pre.outputs.commit-status-context }}
          description: ${{ needs.redeploy-pre.outputs.commit-status-description }}

  notifier:
    name: Notifier
    needs:
      - defaults  # so we can access `inputs.root-sbd` that could have defaulted to `inputs.model`
      - check-spack-yaml  # implies all the spack.yaml-related checks have passed, has appropriate version for the prerelease build
      - check-config  # so we can access potential failures from config/settings.json validation
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: PR Comment Notifier
        id: comment
        uses: access-nri/actions/.github/actions/pr-comment@main
        with:
          pr: ${{ inputs.pr }}
          comment: |
            :rocket: Deploying ${{ inputs.model }} `${{ needs.check-spack-yaml.outputs.release }}` as prerelease `${{ needs.check-spack-yaml.outputs.prerelease }}` with commit ${{ needs.defaults.outputs.head-sha }}
            ${{ needs.check-config.outputs.config-settings-failures != '' && ':warning:There are issues with the `build-cd` deployment configuration. If this is unexpected, let @ACCESS-NRI/model-release know.' || '' }}
            <details>
            <summary>Details and usage instructions</summary>

            This `${{ inputs.model }}` model will be deployed as:
            * `${{ needs.check-spack-yaml.outputs.release }}` as a Release (when merged).
            * `${{ needs.check-spack-yaml.outputs.prerelease }}` as a Prerelease (during this PR).

            This Prerelease is accessible on Gadi using:
            ```bash
            module use /g/data/vk83/prerelease/modules
            module load ${{ needs.defaults.outputs.root-sbd }}/${{ needs.check-spack-yaml.outputs.prerelease }}
            ```
            where the binaries shall be on your `$PATH`.
            This Prerelease is also accessible on Gadi via `/g/data/vk83/prerelease/apps/spack/${{ needs.check-config.outputs.spack-version }}/spack` in the `${{ needs.defaults.outputs.root-sbd }}-${{ needs.check-spack-yaml.outputs.prerelease }}` environment.
            </details>

            :hammer_and_wrench: Using: spack `${{ needs.check-config.outputs.spack-version }}`, spack-packages `${{ needs.check-config.outputs.spack-packages-version}}`, spack-config `${{ needs.check-config.outputs.spack-config-version }}`
            <details>
            <summary>Details</summary>

            It will be deployed using:
            * `access-nri/spack` on branch [`${{ needs.check-config.outputs.spack-version }}`](https://github.com/ACCESS-NRI/spack/tree/releases/v${{ needs.check-config.outputs.spack-version }})
            * `access-nri/spack-packages` version [`${{ needs.check-config.outputs.spack-packages-version }}`](https://github.com/ACCESS-NRI/spack-packages/releases/tag/${{ needs.check-config.outputs.spack-packages-version }})
            * `access-nri/spack-config` version [`${{ needs.check-config.outputs.spack-config-version }}`](https://github.com/ACCESS-NRI/spack-config/releases/tag/${{ needs.check-config.outputs.spack-config-version }})

            If this is not what was expected, commit changes to `config/versions.json`.
            </details>

      - name: PR Description Notifier
        env:
          GH_TOKEN: ${{ github.token }}
          PR_BODY_PATH: ./body.txt
          PR_BODY_PATH_UPDATED: ./updated.body.txt
          PRERELEASE_SECTION_REGEX: "^:rocket: .* :rocket:$"
          PRERELEASE_SECTION: ":rocket: The latest prerelease `${{ needs.defaults.outputs.root-sbd }}/${{ needs.check-spack-yaml.outputs.prerelease }}` at ${{ needs.defaults.outputs.head-sha }} is here: ${{ steps.comment.outputs.comment-link }} :rocket:"
        run: |
          gh pr view ${{ inputs.pr }} --repo ${{ github.repository }} --json body --jq .body > ${{ env.PR_BODY_PATH }}

          # `awk` is a series of `CONDITION { ACTION }` pairs. No 'CONDITION' means 'TRUE', no '{ ACTION }' means 'print'.
          if grep -q '${{ env.PRERELEASE_SECTION_REGEX }}' ${{ env.PR_BODY_PATH }}; then  # there is an existing prerelease section
            # Replace the existing prerelease section
            # `{gsub(...)}`. Always attempt substitution on each line, then:
            # `1`. Always do the default action '{ print }').
            awk '{gsub(/${{ env.PRERELEASE_SECTION_REGEX }}/, "${{ env.PRERELEASE_SECTION }}")}1' ${{ env.PR_BODY_PATH }} > ${{ env.PR_BODY_PATH_UPDATED }}
          else  # a new section is added
            # `1;` -> `TRUE { print }`. Always do the default action (aka 'print') for each line.
            # `END {print(...)}`. If end of file, print the prerelease section.
            awk '1; END {print "\n---\n${{ env.PRERELEASE_SECTION }}"}' ${{ env.PR_BODY_PATH }} > ${{ env.PR_BODY_PATH_UPDATED }}
          fi

          cat ${{ env.PR_BODY_PATH_UPDATED }}

          gh pr edit ${{ inputs.pr }} --repo ${{ github.repository }} --body-file ${{ env.PR_BODY_PATH_UPDATED }}
