name: Deploy Start
concurrency: ${{ inputs.deployment-environment }}
on:
  workflow_call:
    inputs:
      type:
        type: string
        required: true
        description: The type of deployment - either 'Release' or 'Prerelease'
      model:
        type: string
        required: true
        description: The model to deploy
      ref:
        type: string
        required: true
        description: The git commit-ish ref where the `spack.yaml` is located
      version:
        type: string
        required: true
        description: The version for the model being deployed
      env-name:
        type: string
        required: true
        description: The spack-env-compliant environment name for the model
      deployment-environment:
        type: string
        required: true
        description: The GitHub deployment environment name
      root-sbd:
        type: string
        required: true
        description: The root SBD that is being used as the modulefile name
    outputs:
      modules-location:
        value: ${{ jobs.deploy-to-environment.outputs.modules-location }}
        description: The location of the modules directory on the deployment environment
      spack-location:
        value: ${{ jobs.deploy-to-environment.outputs.spack-location }}
        description: The location of the spack directory on the deployment environment
      general-metadata-artifact-glob:
        value: ${{ jobs.deploy-to-environment.outputs.metadata-artifact-name }}
        description: |
          General pattern for the artifact that contains the deployment metadata files for this invocation of the job.
          These files are of the form deploy-metadata.{{inputs.deployment-target}}
env:
  # This attempts to get the spack.yaml model first via the multi-target
  # .spack.definitions.root_package method, then the traditional '.spack.specs[0]'.
  SPACK_YAML_MODEL_YQ: (.spack.definitions[] | select(."ROOT_PACKAGE") | .[][]) // .spack.specs[0]
  SPACK_YAML_MODULEFILE_PROJECTION_YQ: .spack.modules.default.tcl.projections.${{ inputs.root-sbd }}
  METADATA_PATH: /opt/metadata
  ARTIFACT_NAME: deploy-metadata.${{ inputs.deployment-environment }}
jobs:
  deploy-to-environment:
    name: Deploy to ${{ inputs.deployment-environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.deployment-environment }}
    outputs:
      packages-version: ${{ steps.versions.outputs.packages }}
      config-version: ${{ steps.versions.outputs.config }}
      spack-location: ${{ steps.location.outputs.spack }}
      modules-location: ${{ steps.location.outputs.modules }}
      metadata-artifact-name: ${{ env.ARTIFACT_NAME }}
    steps:
      # Deployment
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Get Versions From config/versions.json
        id: versions
        run: |
          echo "spack=$(jq --compact-output --raw-output '.spack' ./config/versions.json)" >> $GITHUB_OUTPUT
          echo "packages=$(jq --compact-output --raw-output '."spack-packages"' ./config/versions.json)" >> $GITHUB_OUTPUT

      - name: Get ${{ inputs.deployment-environment }} Remote Paths
        id: path
        uses: access-nri/build-cd/.github/actions/get-deploy-paths@main
        with:
          spack-installs-root-path: ${{ vars.SPACK_INSTALLS_ROOT_LOCATION }}
          spack-version: ${{ steps.versions.outputs.spack }}
          deployment-environment: ${{ inputs.deployment-environment }}

      - name: Setup SSH
        id: ssh
        uses: access-nri/actions/.github/actions/setup-ssh@main
        with:
          private-key: ${{ secrets.SSH_KEY }}
          hosts: |
            ${{ secrets.HOST }}
            ${{ secrets.HOST_DATA }}

      - name: Prerelease spack.yaml Modifications
        if: inputs.type == 'Prerelease'
        # Modifies the name of the prerelease modulefile to the
        # `pr<number>-<commit>` style. For example, `access-om3/pr12-2`.
        # Also removes the `@git.VERSION` specifier for Prereleases so
        # we don't have to shift tags around.
        run: |
          yq -i '${{ env.SPACK_YAML_MODEL_YQ }} = (${{ env.SPACK_YAML_MODEL_YQ }} | split("@").[0])' spack.yaml
          yq -i '${{ env.SPACK_YAML_MODULEFILE_PROJECTION_YQ }} = "{name}/${{ inputs.version }}"' spack.yaml
          echo '::notice::Prerelease accessible as module `${{ inputs.model}}/${{ inputs.version }}`'

      - name: Copy spack.yaml
        run: |
          rsync -e 'ssh -i ${{ steps.ssh.outputs.private-key-path }}' \
            spack.yaml \
            ${{ secrets.USER }}@${{ secrets.HOST_DATA }}:${{ vars.SPACK_YAML_LOCATION }}/${{ inputs.model }}.spack.yaml

      - name: Fetch git sources for packages to build
        # Workaround for ACCESS-NRI/spack#2.
        # TODO: Remove once underlying spack issue is fixed
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} -i ${{ steps.ssh.outputs.private-key-path }} /bin/bash <<'EOT'

          if [ ! -d "${{ steps.path.outputs.root }}/git_repos" ]; then
            echo "::warning::Unable to find git_repos folder under ${{ steps.path.outputs.root }} - spack will attempt fetch instead"
            exit 0
          fi

          cd "${{ steps.path.outputs.root }}/git_repos" || exit 0

          for package_repo in *; do
            git -C "./$package_repo" fetch --verbose --update-head-ok origin "+refs/heads/*:refs/heads/*"
          done
          EOT

      - name: Deploy to ${{ inputs.deployment-environment }}
        # ssh into deployment environment, create and activate the env, install the spack.yaml.
        run: |
          ssh ${{ secrets.USER}}@${{ secrets.HOST }} -i ${{ steps.ssh.outputs.private-key-path }} /bin/bash <<'EOT'
          # Check that a suitable deployment location exists
          if [ ! -d "${{ steps.path.outputs.root }}" ]; then
            echo '::error::A deployment of spack does not exist in `${{ steps.path.outputs.root }}` for `${{ inputs.deployment-environment }}`'
            exit 1
          fi

          # Export vars.DEPLOYMENT_TARGET
          export DEPLOYMENT_TARGET="${{ vars.DEPLOYMENT_TARGET }}"
          echo "DEPLOYMENT_TARGET exported as $DEPLOYMENT_TARGET"

          # Update spack-packages
          git -C ${{ steps.path.outputs.spack-packages }} fetch
          git -C ${{ steps.path.outputs.spack-packages }} checkout --force ${{ steps.versions.outputs.packages }}
          git -C ${{ steps.path.outputs.spack-packages }} reset --hard origin/${{ steps.versions.outputs.packages }}

          # Enable spack
          . ${{ steps.path.outputs.spack-config }}/spack-enable.bash

          # Create environment and build model
          spack env create ${{ inputs.env-name }} ${{ vars.SPACK_YAML_LOCATION }}/${{ inputs.model }}.spack.yaml
          spack env activate ${{ inputs.env-name }}
          spack --debug install --fresh ${{ vars.SPACK_INSTALL_PARALLEL_JOBS }} || exit $?
          spack module tcl refresh -y
          EOT

      - name: Export deployment target locations
        id: location
        run: |
          echo "spack=${{ steps.path.outputs.spack }}" >> $GITHUB_OUTPUT
          echo "modules=${{ vars.DEPLOYED_MODULES_DIR }}" >> $GITHUB_OUTPUT

      - name: Get metadata from ${{ inputs.deployment-environment }}
        env:
          SPACK_ENV_PATH: ${{ steps.path.outputs.spack }}/../environments/${{ inputs.env-name }}
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} -i ${{ steps.ssh.outputs.private-key-path }} /bin/bash <<'EOT'
          # Export vars.DEPLOYMENT_TARGET
          export DEPLOYMENT_TARGET="${{ vars.DEPLOYMENT_TARGET }}"
          echo "DEPLOYMENT_TARGET exported as $DEPLOYMENT_TARGET"

          . ${{ steps.path.outputs.spack-config }}/spack-enable.bash
          spack env activate ${{ inputs.env-name }}

          spack find --paths > ${{ env.SPACK_ENV_PATH }}/spack.location
          spack find --format '{hash} {prefix}' | jq --raw-input --null-input '[inputs | split(" ") | {(.[0]): (.[1])}] | add' > ${{ env.SPACK_ENV_PATH }}/spack.location.json

          # Get the repos associated with the packages for the build database
          jq -n '{}' > ${{ env.SPACK_ENV_PATH }}/build-db-pkgs.json
          for pkg in ${{ vars.BUILD_DB_PACKAGES }}; do
            pkg_repo_url=$(spack python -c "import spack.spec; print(spack.spec.Spec('$pkg').package_class.git)")

            # We get the version of $pkg from spack.lock, and then strip
            # potential 'git.' and '=VERSION' parts from 'git.TAG=VERSION'
            version=$(jq --compact-output --raw-output \
              --arg p "$pkg" \
              '.concrete_specs | to_entries[].value | select(.name == $p) | .version
                | match("^(?:git.)?([^=]*)")
                | .captures[0].string' \
              ${{ env.SPACK_ENV_PATH}}/spack.lock
            )

            # Example:
            # pkg_repo_url = https://github.com/ACCESS-NRI/MOM5.git, which is then stripped of the '.git'.
            # version = 2024.08.11, giving
            # pkg_release_url = https://github.com/ACCESS-NRI/MOM5/releases/tag/2024.08.11
            pkg_release_url="${pkg_repo_url%.*}/releases/tag/${version}"

            echo "$pkg pkg_repo_url is $pkg_repo_url, pkg_release_url is $pkg_release_url, version is $version"
            jq \
              --arg p "$pkg" \
              --arg r "$pkg_release_url" \
              '. += {($p): ($r)}' \
              ${{ env.SPACK_ENV_PATH }}/build-db-pkgs.json > ${{ env.SPACK_ENV_PATH }}/build-db-pkgs.json.tmp
            mv -f ${{ env.SPACK_ENV_PATH }}/build-db-pkgs.json.tmp ${{ env.SPACK_ENV_PATH }}/build-db-pkgs.json
          done

          spack env deactivate
          EOT

      # Release
      - name: Get Release Metadata
        env:
          # TODO: Can we put both envs above in a $GITHUB_ENV file instead?
          SPACK_ENV_PATH: ${{ steps.path.outputs.spack }}/../environments/${{ inputs.env-name }}
        run: |
          rsync -e 'ssh -i ${{ steps.ssh.outputs.private-key-path }}' \
            '${{ secrets.USER}}@${{ secrets.HOST_DATA }}:${{ env.SPACK_ENV_PATH }}/spack.*' \
            ./${{ env.ARTIFACT_NAME }}

          # Rename the files to include the deployment environment
          cd ./${{ env.ARTIFACT_NAME }}
          for file in *; do
            mv "$file" "${{ inputs.deployment-environment }}.$file"
          done
          cd -

      - name: Upload Metadata Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ./${{ env.ARTIFACT_NAME }}/*
